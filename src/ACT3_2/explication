ğŸ§® Serveur Multithread de Calcul - Projet Java
Ce projet implÃ©mente un serveur multithread en Java permettant Ã  plusieurs clients de se connecter simultanÃ©ment pour effectuer des opÃ©rations mathÃ©matiques simples.

ğŸ“ Structure du projet
ğŸ§© Classes principales
1. serveurMultithread.java
Classe principale du serveur.

Ã‰coute sur le port 1234.

Accepte les connexions clientes et lance un thread (clientproc) pour chaque client.

Affiche le nombre total d'opÃ©rations effectuÃ©es.

2. client.java
Classe cliente.

Se connecte au serveur (adresse IP : 192.168.1.15, port : 1234).

Saisit deux opÃ©randes et un opÃ©rateur via la console.

Envoie un objet operation au serveur et affiche le rÃ©sultat.

3. clientproc.java
Thread gÃ©rant chaque client connectÃ©.

ReÃ§oit un objet operation, effectue le calcul et renvoie le rÃ©sultat.

Met Ã  jour un compteur global d'opÃ©rations (nbop).

4. operation.java
Classe sÃ©rialisable reprÃ©sentant une opÃ©ration mathÃ©matique.

Contient :

Deux opÃ©randes (opd1, opd2)

Un opÃ©rateur (op)

Un rÃ©sultat (res)

MÃ©thodes de calcul : somme(), soustraction(), multiplication(), division().

ğŸš€ FonctionnalitÃ©s
âœ… Connexions clientes multiples

âœ… OpÃ©rations supportÃ©es : +, -, *, /

âœ… Gestion des erreurs (division par zÃ©ro, opÃ©rateur invalide)

âœ… Communication via sockets et sÃ©rialisation d'objets

ğŸ› ï¸ Technologies utilisÃ©es
Java SE

Sockets TCP

Multithreading

SÃ©rialisation d'objets

â–¶ï¸ Comment exÃ©cuter
Compiler tous les fichiers .java :

bash
javac ACT3_2/*.java
Lancer le serveur :

bash
java ACT3_2.serveurMultithread
Lancer un ou plusieurs clients :

bash
java ACT3_2.client
ğŸ“Œ Notes
Pensez Ã  modifier l'adresse IP dans client.java selon votre configuration rÃ©seau.

Le serveur doit Ãªtre dÃ©marrÃ© avant les clients.

Le compteur nbop est statique et partagÃ© entre tous les threads.
--le sychronized
ğŸŒŸ Le Contexte

Tu as une classe clientproc qui hÃ©rite de Thread.
Donc plusieurs threads (clients) peuvent sâ€™exÃ©cuter en mÃªme temps, chacun traitant une requÃªte (une opÃ©ration).

Le champ suivant est partagÃ© entre tous les threads :

static int nbop = 0;


Cela signifie que tous les threads voient et modifient la mÃªme variable nbop.

âš ï¸ Le problÃ¨me sans synchronized

Si plusieurs threads exÃ©cutent cette partie en mÃªme temps :

nbop++;


alors :

Thread 1 lit nbop (par exemple 5)

Thread 2 lit aussi nbop (toujours 5)

Thread 1 ajoute 1 â†’ met 6

Thread 2 ajoute 1 â†’ met aussi 6 âŒ
âœ le compteur aurait dÃ» Ãªtre 7, mais il reste 6 (perte dâ€™incrÃ©mentation)

Câ€™est ce quâ€™on appelle un problÃ¨me de concurrence (race condition).

âœ… Lâ€™effet de synchronized

La ligne suivante :

synchronized (verrou) {
    nbop++;
}


signifie :

â€œPendant que ce thread est dans ce bloc, aucun autre thread ne peut utiliser le mÃªme objet verrou en synchronized.â€

Autrement dit, un seul thread Ã  la fois peut exÃ©cuter le bloc de code protÃ©gÃ©.
Ainsi, nbop++ se fait de maniÃ¨re atomique (sÃ©curisÃ©e).

